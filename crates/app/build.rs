//! Build script for generating the index pipeline FSM.

use std::collections::HashSet;
use std::error::Error;
use std::path::PathBuf;
use std::{env, fmt, fs};

#[derive(Debug)]
enum BuildError {
    MissingEnv {
        var: &'static str,
        source: env::VarError,
    },
    ReadSpec {
        path: PathBuf,
        source: std::io::Error,
    },
    InvalidTransition {
        raw_line: String,
    },
    InvalidState {
        state: String,
    },
    UnknownState {
        state: String,
    },
    WriteOutput {
        path: PathBuf,
        source: std::io::Error,
    },
}

impl fmt::Display for BuildError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::MissingEnv { var, .. } => write!(f, "missing environment variable {var}"),
            Self::ReadSpec { path, .. } => write!(f, "failed to read {}", path.display()),
            Self::InvalidTransition { raw_line } => {
                write!(f, "invalid transition line: {raw_line}")
            },
            Self::InvalidState { state } => write!(f, "invalid state identifier: {state}"),
            Self::UnknownState { state } => {
                write!(f, "transition references unknown state: {state}")
            },
            Self::WriteOutput { path, .. } => write!(f, "failed to write {}", path.display()),
        }
    }
}

impl Error for BuildError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        if let Self::MissingEnv { source, .. } = self {
            return Some(source);
        }
        if let Self::ReadSpec { source, .. } = self {
            return Some(source);
        }
        if let Self::WriteOutput { source, .. } = self {
            return Some(source);
        }
        None
    }
}

fn main() -> Result<(), BuildError> {
    let spec_path = spec_path()?;
    println!("cargo:rerun-if-changed={}", spec_path.display());

    let spec = read_spec(&spec_path)?;
    let (states, transitions) = parse_spec(&spec)?;
    let code = render_code(&states, &transitions);
    write_output(&code)?;
    Ok(())
}

fn spec_path() -> Result<PathBuf, BuildError> {
    let manifest_dir =
        PathBuf::from(
            env::var("CARGO_MANIFEST_DIR").map_err(|err| BuildError::MissingEnv {
                var: "CARGO_MANIFEST_DIR",
                source: err,
            })?,
        );
    Ok(manifest_dir.join("specs/index_pipeline.fsm"))
}

fn read_spec(spec_path: &PathBuf) -> Result<String, BuildError> {
    fs::read_to_string(spec_path).map_err(|err| BuildError::ReadSpec {
        path: spec_path.clone(),
        source: err,
    })
}

type SpecStates = Vec<String>;
type SpecTransition = (String, String);
type SpecTransitions = Vec<SpecTransition>;
type ParsedSpec = (SpecStates, SpecTransitions);

fn parse_spec(spec: &str) -> Result<ParsedSpec, BuildError> {
    let mut states = Vec::new();
    let mut state_set = HashSet::new();
    let mut transitions = Vec::new();

    for raw_line in spec.lines() {
        let line = raw_line.split('#').next().unwrap_or("").trim();
        if line.is_empty() {
            continue;
        }

        if let Some((from, to)) = line.split_once("->") {
            let from = from.trim();
            let to = to.trim();
            if from.is_empty() || to.is_empty() {
                return Err(BuildError::InvalidTransition {
                    raw_line: raw_line.to_owned(),
                });
            }
            transitions.push((from.to_owned(), to.to_owned()));
            continue;
        }

        if !is_valid_ident(line) {
            return Err(BuildError::InvalidState {
                state: line.to_owned(),
            });
        }
        if state_set.insert(line.to_owned()) {
            states.push(line.to_owned());
        }
    }

    for (from, to) in &transitions {
        if !state_set.contains(from) {
            return Err(BuildError::UnknownState {
                state: from.clone(),
            });
        }
        if !state_set.contains(to) {
            return Err(BuildError::UnknownState { state: to.clone() });
        }
    }

    Ok((states, transitions))
}

fn render_code(states: &[String], transitions: &[(String, String)]) -> String {
    let mut code = String::new();
    code.push_str("// @generated by build.rs\n");
    code.push_str("/// Index pipeline state machine states.\n");
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n");
    code.push_str("pub enum IndexPipelineState {\n");
    for state in states {
        code.push_str("    /// ");
        code.push_str(state);
        code.push_str(" state.\n");
        code.push_str("    ");
        code.push_str(state);
        code.push_str(",\n");
    }
    code.push_str("}\n\n");

    code.push_str("impl IndexPipelineState {\n");
    code.push_str("    /// Return the stable string form for this state.\n");
    code.push_str("    pub const fn as_str(&self) -> &'static str {\n");
    code.push_str("        match self {\n");
    for state in states {
        code.push_str("            Self::");
        code.push_str(state);
        code.push_str(" => \"");
        code.push_str(state);
        code.push_str("\",\n");
    }
    code.push_str("        }\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    code.push_str("/// Ordered list of index pipeline states.\n");
    code.push_str("pub const INDEX_PIPELINE_STATES: &[IndexPipelineState] = &[\n");
    for state in states {
        code.push_str("    IndexPipelineState::");
        code.push_str(state);
        code.push_str(",\n");
    }
    code.push_str("];\n\n");

    code.push_str("/// Allowed state transitions for the index pipeline.\n");
    code.push_str(
        "pub const INDEX_PIPELINE_TRANSITIONS: &[(IndexPipelineState, IndexPipelineState)] = &[\n",
    );
    for (from, to) in transitions {
        code.push_str("    (IndexPipelineState::");
        code.push_str(from);
        code.push_str(", IndexPipelineState::");
        code.push_str(to);
        code.push_str("),\n");
    }
    code.push_str("];\n");

    code
}

fn write_output(code: &str) -> Result<(), BuildError> {
    let out_dir = PathBuf::from(env::var("OUT_DIR").map_err(|err| BuildError::MissingEnv {
        var: "OUT_DIR",
        source: err,
    })?);
    let dest = out_dir.join("index_pipeline_fsm.rs");
    fs::write(&dest, code).map_err(|err| BuildError::WriteOutput {
        path: dest,
        source: err,
    })
}

fn is_valid_ident(candidate: &str) -> bool {
    let mut chars = candidate.chars();
    let Some(first) = chars.next() else {
        return false;
    };
    if !(first.is_ascii_alphabetic() || first == '_') {
        return false;
    }
    chars.all(|ch| ch.is_ascii_alphanumeric() || ch == '_')
}
